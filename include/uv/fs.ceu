#ifndef _UV_FS_CEU
#define _UV_FS_CEU

#include "c.ceu"
#include "uv/uv.ceu"

native/const
    _O_APPEND,
    _O_CREAT,
    _O_RDONLY,
    _O_TRUNC,
    _O_WRONLY,
    _S_IRUSR,
    _S_IWUSR,
    _S_IRGRP,
    _S_IWGRP,
    _S_IROTH,
;

native/plain
    _uv_fs_t,
    _uv_stat_t,
;

native
    _ceu_uv_fs_read,
    _ceu_uv_fs_open,
    _ceu_uv_fs_write,
    _ceu_uv_fs_fstat,
;

native/nohold
    _ceu_uv_fs_close,
    _ceu_uv_fs_close_,
    _uv_fs_req_cleanup,
;

input _uv_fs_t&& UV_FS;

data UV_FS_File with
    var&[] byte  buf;
    var    usize off =  0;
    var    int   fd  = -1;
    event  void  ok;
end

code/await UV_FS_Open (var _char&& path, var usize? buf_n, var int? flags, var int? mode)
                        -> (var UV_FS_File file)
                            -> int
do
    if not buf_n? then
        buf_n = 1024;
    end
    if not flags? then
        flags = _O_RDONLY;
    end
    if not mode? then
        mode = 0;
    end

    var[buf_n!*] byte buf;
    file = val UV_FS_File(&buf,_,_,_);

    var _uv_fs_t req_open  = _;
    var _uv_fs_t req_close = _;

    var int ret;
    do
        ret = _ceu_uv_fs_open(&&req_open, _PURIFY(&&path[0]), flags!, mode!);
    finalize (req_open) with
        _ceu_uv_fs_close_(&&req_close, req_open.result);
        _uv_fs_req_cleanup(&&req_open);
    end
#if 1
    _ceu_dbg_assert(ret == 0);  // libuv seems to always return 0
#else
    if ret < 0 then
        escape ret;
    end
#endif

    var _uv_fs_t&& req = await UV_FS until req==&&req_open;
    file.fd = req_open.result;
    if file.fd < 0 then
        escape file.fd;
    end
    emit file.ok;

    await FOREVER;
end

code/await UV_FS_Read_N (var& UV_FS_File file, var usize n) -> ssize
do
    _ceu_dbg_assert($$file.buf-$file.buf >= n);

    var _uv_buf_t buf = _;
    var _uv_fs_t  req = _;

    var int times = _;
    var int free = ($$file.buf - _ceu_vector_getini(&&file.buf)) as int;
    if free >= n then
        times = 1;    // requires a single read
        buf = _uv_buf_init(&&file.buf[$file.buf], n);
    else
        times = 2;    // requires a second read
        buf = _uv_buf_init(&&file.buf[$file.buf], free);
    end

    var usize n_read = 0;

    var int i;
    loop i in [1->times] do
        var ssize ret;
        do
            ret = _ceu_uv_fs_read(&&req, file.fd, &&buf, 1, file.off);
        finalize (req, buf) with
            _uv_fs_req_cleanup(&&req);
        end
        if ret < 0 then
            if i == 1 then
                escape ret;
            else
                escape n_read;
            end
        end

        var _uv_fs_t&& req_ = await UV_FS until req_==&&req;
        if req.result < 0 then
            if n == 1 then
                escape req.result;
            else
                escape n_read;
            end
        end

        _ceu_dbg_assert(n >= req.result);
        file.off = file.off + req.result;
        n_read  = n_read  + req.result;
        _ceu_vector_setlen(&&file.buf, $file.buf+req.result, 1);

        // second read
        if times == 2 then
            buf = _uv_buf_init(&&file.buf[free], n-free);
        end
    end

    escape n_read;
end

code/await UV_FS_Read_Line (var& UV_FS_File file, var usize? by, var&[] byte line)
                                -> ssize
do
    var usize n_read = 0;

    var usize i;
    loop i in [1 -> $file.buf] do       // "[0 -> $file.buf[" may underflow
        var byte c = file.buf[0];
        $file.buf = $file.buf - 1;
        n_read = n_read + 1;
        if c == {'\n'} then
            escape n_read;
        else
            line = line .. [c];
        end
    end

    if not by? then
        by = 80;
    end

    loop do
        var usize n = do
            var usize free = $$file.buf - $file.buf;
            if by! <= free then
                escape by!;
            else
                escape free;
            end
        end;

        if n == 0 then
            escape {UV_ENOBUFS};
        end

        var ssize n_ = await UV_FS_Read_N(&file, n);   // may read less than "n" bytes
        if n_ < 0 then
            escape n;
        else/if n_ == 0 then
            escape {UV_EOF};
        end
        n = n_ as usize;

        _ceu_dbg_assert($file.buf == n);
        var usize i;
        loop i in [0 -> $file.buf[ do
            var byte c = file.buf[0];
            $file.buf = $file.buf - 1;
            n_read = n_read + 1;
            if c == {'\n'} then
                escape n_read;
            else
                line = line .. [c];
            end
        end
    end
end

code/await UV_FS_Write_N (var& UV_FS_File file, var usize n) -> ssize
do
    var _uv_buf_t buf = _;
    var _uv_fs_t  req = _;

    var int times = _;
    var int filled = ($$file.buf - _ceu_vector_getini(&&file.buf)) as int;
    if filled >= n then
        times = 1;   // requires a single write
        buf = _uv_buf_init(&&file.buf[0], n);
    else
        times = 2;   // requires a second write
        buf = _uv_buf_init(&&file.buf[0], filled);
    end

    var usize n_written = 0;

    var int i;
    loop i in [1->times] do
        var ssize ret;
        do
            ret = _ceu_uv_fs_write(&&req, file.fd, &&buf, 1, file.off);
        finalize (req, buf) with
            _uv_fs_req_cleanup(&&req);
        end
        if ret < 0 then
            if i == 1 then
                escape ret;
            else
                escape n_written;
            end
        end

        var _uv_fs_t&& req_ = await UV_FS until req_==&&req;
        if req.result < 0 then
            if i == 1 then
                escape req.result;
            else
                escape n_written;
            end
        end

        _ceu_dbg_assert(n >= req.result);
        file.off  = file.off  + req.result;
        n_written = n_written + req.result;
        $file.buf = $file.buf - req.result;

        // second read
        if times == 2 then
            buf = _uv_buf_init(&&file.buf[0], n-req.result);
        end
    end

    escape n_written;
end

code/await UV_FS_Fstat (var& UV_FS_File file, var& _uv_stat_t stat) -> int
do
    var _uv_fs_t req_fstat = _;
    do finalize with
        _uv_fs_req_cleanup(&&req_fstat);
    end

    var int ret;
    do
        ret = _ceu_uv_fs_fstat(&&req_fstat, file.fd);
    finalize (req_fstat) with
        _uv_fs_req_cleanup(&&req_fstat);
    end

    if ret < 0 then
        escape ret;
    end
    var _uv_fs_t&& req = await UV_FS until req==&&req_fstat;

    stat = *(req_fstat.ptr as _uv_stat_t&&);

    escape 0;
end

native/pos do
    ##define ceu_uv_fs_open(a,b,c,d)    uv_fs_open(&ceu_uv_loop,a,b,c,d,ceu_uv_fs_cb)
    ##define ceu_uv_fs_close(a,b)       uv_fs_close(&ceu_uv_loop,a,b,ceu_uv_fs_close_cb)
    ##define ceu_uv_fs_close_(a,b)      uv_fs_close(&ceu_uv_loop,a,b,NULL); \\
                                        ceu_uv_fs_close_cb(a)
    ##define ceu_uv_fs_read(a,b,c,d,e)  uv_fs_read(&ceu_uv_loop,a,b,c,d,e,ceu_uv_fs_cb)
    ##define ceu_uv_fs_write(a,b,c,d,e) uv_fs_write(&ceu_uv_loop,a,b,c,d,e,ceu_uv_fs_cb)
    ##define ceu_uv_fs_fstat(a,b)       uv_fs_fstat(&ceu_uv_loop,a,b,ceu_uv_fs_cb)

    void ceu_uv_fs_cb (uv_fs_t* req) {
        ceu_input(CEU_INPUT_UV_FS, &req);
    }

    void ceu_uv_fs_close_cb (uv_fs_t* req) {
        //TODO???
        //assert(req->result == 0);
        uv_fs_req_cleanup(req);
    }
end

#endif
