#ifndef _UV_STREAM_CEU
#define _UV_STREAM_CEU

#include "c.ceu"
#include "uv/uv.ceu"

native/plain
    _uv_connect_t,
    _uv_handle_t,
    _uv_stream_t,
    _uv_write_t,
    _tceu_uv_stream_data,
;

native/pure
    _uv_is_readable,
    _uv_is_writable,
;

native/nohold
    _ceu_uv_close,
    _ceu_uv_free,
    _ceu_uv_listen,       // TODO: unlisten?
    _ceu_uv_write,        // TODO: write_stop?
    _uv_accept,
    _uv_close,
    _uv_ip4_addr,
    _uv_read_stop,
;

native
    _ceu_uv_read_start,
;

native/pre do
    typedef struct tceu_uv_stream_data {
        tceu_vector* vector;
        usize        n;         // n=0 means read any number of bytes and generates an input
    } tceu_uv_stream_data;
end

input (_uv_stream_t&&, int)   UV_STREAM_ERROR;
input (_uv_stream_t&&, int)   UV_STREAM_LISTEN;
input (_uv_connect_t&&,int)   UV_STREAM_CONNECT;
input (_uv_stream_t&&, ssize) UV_STREAM_READ;
input (_uv_write_t&&,  int)   UV_STREAM_WRITE;

// TODO: full-duplex: read/write handle

data UV_Stream with
    var&[] byte         buffer;
    var&   _uv_stream_t handle;
end

code/await UV_Stream_Listen (var& UV_Stream stream, var int? backlog)
                                -> (event none ok)
                                    -> int // err
do
    if not backlog? then
        backlog = 128;
    end

    var int err1 = _ceu_uv_listen(&&stream.handle, backlog!);
    if err1 != 0 then
        escape err1;
    end

    var _uv_stream_t&& s;
    var int err2;
    every (s,err2) in UV_STREAM_LISTEN do
        if s == &&stream.handle then
            _ceu_dbg_assert(err2 == 0);   // UV_STREAM_ERROR already aborted me
            emit ok;
        end
    end
end

code/await UV_Stream_Read_N (var& UV_Stream stream, var usize? n) -> ssize
do
    var usize? n_togo;
    var int?   times;
    var int?   free;
    if n? then
        _ceu_dbg_assert($$stream.buffer >= n!);

        // "buffer" already contains the requested "n"
        if $stream.buffer >= n! then
            escape 0;
        end
        n = n! - $stream.buffer;

        free = ($$stream.buffer - _ceu_vector_ptr(&&stream.buffer):ini) as int;
        if free! >= n! then
            times = 1;    // requires a single read
            n_togo = n!;
        else
            times = 2;    // requires a second read
            n_togo = free!;
        end
        (stream.handle._data as _tceu_uv_stream_data&&):n = n_togo!;
    else
        times = 1;
        (stream.handle._data as _tceu_uv_stream_data&&):n = 0;
    end

    var ssize n_read  = 0;

    var int i;
    loop i in [1->times!] do
        var int err;
        do
            err = _ceu_uv_read_start(&&stream.handle);
        finalize (stream.handle) with
            _uv_read_stop(&&stream.handle);   // finalize after each UV_STREAM_READ
        end
        if err != 0 then
            if i == 1 then
                escape err;
            else
                escape n_read;
            end
        end

        var _uv_stream_t&& s;
        var ssize ret;
        (s, ret) = await UV_STREAM_READ until (s == &&stream.handle);
        if ret <= 0 then
            if i == 1 then
                escape ret;
            else
                escape n_read;
            end
        end
        if n? then
            _ceu_dbg_assert(ret == n_togo!);
        end
        n_read = n_read + ret;

        // second read
        if times! == 2 then
            n_togo = (n! - free!);
            (stream.handle._data as _tceu_uv_stream_data&&):n = n_togo!;
        end
    end

    escape n_read;
end

code/await UV_Stream_Read_Line (var& UV_Stream stream, var&[] byte line)
                                -> ssize
do
    var usize n_read = 0;

    do/_
        var usize i;
        loop i in [1 -> $stream.buffer] do       // "[0 -> $stream.buf[" may underflow
            var byte c = stream.buffer[0];
            $stream.buffer = $stream.buffer - 1;
            n_read = n_read + 1;
            if c == {'\n'} then
                escape n_read;
            else
                line = line .. [c];
            end
        end
    end

    loop do
        var ssize n = await UV_Stream_Read_N(&stream,_);
        if n < 0 then
            escape n;
        end

        _ceu_dbg_assert($stream.buffer == n);
        var usize i;
        loop i in [0 -> $stream.buffer[ do
            var byte c = stream.buffer[0];
            $stream.buffer = $stream.buffer - 1;
            n_read = n_read + 1;
            if c == {'\n'} then
//{ *@(&&stream.buffer[_ceu_vector_idx(&&stream.buffer, $stream.buffer)]) = '\0'; }
//_printf(">3> |%s|\n", &&stream.buffer[0]);
                escape n_read;
            else
                line = line .. [c];
            end
        end
    end
end

code/await UV_Stream_Write_N (var& UV_Stream stream, var usize? n) -> ssize
do
    if not n? then
        n = $stream.buffer;
    end

    var int   times = _;
    var usize n_togo = _;
    var int filled = ($$stream.buffer - _ceu_vector_ptr(&&stream.buffer):ini) as int;
    if filled >= n! then
        times  = 1;   // requires a single write
        n_togo = n!;
    else
        times  = 2;   // requires a second write
        n_togo = filled;
    end

    var _uv_buf_t buf = _uv_buf_init(&&stream.buffer[0], n_togo);
    _ceu_dbg_assert(_uv_is_writable(&&stream.handle));

    var usize n_written = 0;

    var int i;
    loop i in [1->times] do
        var&? _uv_write_t req = &_malloc(sizeof(_uv_write_t))
            finalize (req) with
                // free on uv callback
            end;
        if not req? then
            if i == 1 then
                escape _UV_EAI_MEMORY;
            else
                escape n_written;
            end
        end

        var int ret = _ceu_uv_write(&&req!, &&stream.handle, &&buf);
        if ret < 0 then
            if i == 1 then
                escape ret;
            else
                escape n_written;
            end
        end

        var _uv_write_t&& w;
        (w, ret) = await UV_STREAM_WRITE until w==&&req!;
        if ret < 0 then
            if i == 1 then
                escape ret;
            else
                escape n_written;
            end
        end
        // "ret" does not contain the number of bytes, let's trust on "n_togo"

        //_ceu_dbg_assert(n! >= ret);
        //_ceu_dbg_assert(n_togo == ret);
        n_written = n_written + n_togo;
        $stream.buffer = $stream.buffer - n_togo;

        // second read
        if times == 2 then
            n_togo = n!-n_togo;
            buf = _uv_buf_init(&&stream.buffer[0], n_togo);
        end
    end

    escape n_written;
end

native/pos do
#if 0
    ##define ceu_uv_close(a)           if (!uv_is_closing(a)) { uv_close(a,ceu_uv_free); }
#endif
    ##define ceu_uv_close(a)           uv_close(a,ceu_uv_free)
    ##define ceu_uv_listen(a,b)        uv_listen(a,b,ceu_uv_listen_cb)
    ##define ceu_uv_read_start(a)      uv_read_start(a,ceu_uv_read_alloc,ceu_uv_read_start_cb);
    ##define ceu_uv_write(a,b,c)       uv_write(a,b,c,1,ceu_uv_write_cb)

    void ceu_uv_free (uv_handle_t* h) {
        // TODO: other stream types
/*
        if (h->type == UV_TCP) {
            uv_stream_t* s = (uv_stream_t*)h;
            if (s->connect_req != NULL) {
printf(">>> FREE\n");
                free(s->connect_req);
                s->connect_req = NULL;
            }
        }
*/
        free(h);
    }

    void ceu_uv_listen_cb (uv_stream_t* s, int err) {
        ceu_dbg_assert(err >= 0);
        tceu_input_UV_STREAM_LISTEN p = { s, err };
        ceu_input(CEU_INPUT_UV_STREAM_LISTEN, &p);
    }

    ##define CEU_UV_STREAM_READ_ALLOC_DYN_INIT 1024

    void ceu_uv_read_alloc (uv_handle_t* h, size_t size, uv_buf_t* buf) {
        tceu_uv_stream_data* data = (tceu_uv_stream_data*) h->data;
        tceu_vector* vec = data->vector;
        usize        n   = data->n;
        ceu_dbg_assert(vec != NULL);

        if (vec->is_dyn && !vec->is_freezed) {
            ceu_vector_setmax(vec, (n==0 ? CEU_UV_STREAM_READ_ALLOC_DYN_INIT : n), 0);
        }

        *buf = uv_buf_init(ceu_vector_buf_get(vec,vec->len), (n==0 ? (vec->max-vec->ini) : n));
    }

    void ceu_uv_read_start_cb(uv_stream_t* s, ssize_t n, const uv_buf_t* _) {
        //ceu_dbg_assert(n != 0); // TODO: if this happens, try to understand why
        // ok, it happend, the underlying syscall may fail with EGAIN/EWOULDBLOCK

        tceu_uv_stream_data* data = (tceu_uv_stream_data*) s->data;
        ceu_dbg_assert(data != NULL);
        ceu_dbg_assert(n<0 || data->n==0 || data->n>=n);
        if (data->n != 0) {
            data->n -= n;
        }

        tceu_vector* vec = data->vector;
        if (n > 0) {
            if (ceu_vector_setlen_could(vec,vec->len+n,1) == 0) {
                n = UV_ENOBUFS;
            } else {
                ceu_vector_setlen(vec,vec->len+n,1);
            }
        }

        if (n < 0) {
            tceu_input_UV_STREAM_ERROR p = { s, n };
            ceu_input(CEU_INPUT_UV_STREAM_ERROR, &p);
        }

        if (data->n == 0) {
            tceu_input_UV_STREAM_READ p = { s, n };
            ceu_input(CEU_INPUT_UV_STREAM_READ, &p);
        }
    }

    void ceu_uv_write_cb (uv_write_t* req, int err) {
        if (err < 0) {
            // if the "assert" fails, see if the error makes sense and extend it
            ceu_dbg_assert(err == UV__EOF);
            tceu_input_UV_STREAM_ERROR p = { req->handle, err };
            ceu_input(CEU_INPUT_UV_STREAM_ERROR, &p);
        }
        tceu_input_UV_STREAM_WRITE p = { req, err };
        ceu_input(CEU_INPUT_UV_STREAM_WRITE, &p);
        free(req);
    }
end

#endif
