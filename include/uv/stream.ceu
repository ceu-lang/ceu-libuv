#ifndef _UV_STREAM_CEU
#define _UV_STREAM_CEU

#include "c.ceu"
#include "uv/uv.ceu"

native/plain
    _uv_connect_t,
    _uv_handle_t,
    _uv_stream_t,
    _uv_write_t,
;

native/pure
    _uv_is_readable,
    _uv_is_writable,
;

native/nohold
    _ceu_uv_close,
    _ceu_uv_free,
    _ceu_uv_listen,       // TODO: unlisten?
    _ceu_uv_write,        // TODO: write_stop?
    _uv_accept,
    _uv_close,
    _uv_ip4_addr,
    _uv_read_stop,
;

native
    _ceu_uv_read_start,
;

input (_uv_stream_t&&, int)   UV_STREAM_ERROR;
input (_uv_stream_t&&, int)   UV_STREAM_LISTEN;
input (_uv_connect_t&&,int)   UV_STREAM_CONNECT;
input (_uv_stream_t&&, ssize) UV_STREAM_READ;
input (_uv_write_t&&,  int)   UV_STREAM_WRITE;

data UV_Stream with
    var&[] byte         buffer;
    var&   _uv_stream_t handle;
end

code/await UV_Stream_Listen (var& UV_Stream stream, var int? backlog)
                                -> (event void ok)
                                    -> int // err
do
    if not backlog? then
        backlog = 128;
    end

    var int err1 = _ceu_uv_listen(&&stream.handle, backlog!);
    if err1 != 0 then
        escape err1;
    end

    var _uv_stream_t&& s;
    var int err2;
    every (s,err2) in UV_STREAM_LISTEN do
        if s == &&stream.handle then
            _ceu_dbg_assert(err2 == 0);   // UV_STREAM_ERROR already aborted me
            emit ok;
        end
    end
end

code/await UV_Stream_Read_N (var& UV_Stream stream, var ssize? n) -> ssize
do
    if not n? then
        n = 1;          // terminates after reading anything
    end
    _ceu_dbg_assert($$file.buffer >= n!);

    if $file.buffer >= n! then
        escape 0;
    end
    n = n! - $file.buffer;

// TODO: circular

    var int err;
    do
        err = _ceu_uv_read_start(&&stream.handle);
    finalize (stream.handle) with
        _uv_read_stop(&&stream.handle);   // finalize after each UV_STREAM_READ
    end
    if err != 0 then
        escape err;
    end

    var _uv_stream_t&& s;
    var ssize n_tot = 0;
    var ssize n_now;
    every (s, n_now) in UV_STREAM_READ do
        if s == &&stream.handle then
            if n_now <= 0 then
                escape n_now;
            end
            n_tot = n_tot + n_now;
_printf("+++ %ld -> %ld\n", n_now, n_tot);
            if n_tot >= n! then
                escape n_tot;
            end
        end
    end
end

#if 0
code/await UV_Stream_Read_Until (var&? UV_Stream_Read reader, var usize limit) -> int
do
    watching reader do
        if reader.next >= limit then
            escape 0;
        end
        loop do
            var usize dt = await reader.ok;
/*
            if dt < 0 then
                // TODO: versions w/ assert/escape
                _printf("error[%d]: %s\n", dt, _uv_strerror(dt));
                _assert(0);
                escape dt;
            end
*/
            if reader.next >= limit then
                escape 0;
            end
        end
    end
    escape -1;
end

code/await UV_Stream_ReadLine (var& _uv_stream_t stream, var&[] byte string)
                                -> void
do
    var&? UV_Stream_Read s = spawn UV_Stream_Read(&stream,&string);
    watching s do
        loop do
            await s.ok;
            var byte n = 0;
            var byte c = 0;
            var int ret = _sscanf(&&string[0], "%*[^\n]%[\n]%c", &&n,&&c);
            _ceu_dbg_assert(ret < 2);
            if ret == 1 then
                _ceu_dbg_assert(n == {'\n'});
                escape;
            end
        end
    end
    _ceu_dbg_assert(0);   // UV_STREAM_ERROR has already aborted me
end
#endif

code/await UV_Stream_Write_N (var& UV_Stream stream, var usize? n) -> ssize
do
    if not n? then
        n = $stream.buffer;
    end

    var&? _uv_write_t req = &_malloc(sizeof(_uv_write_t))
        finalize (req) with
            // free on uv callback
        end;
    if not req? then
        escape _UV_EAI_MEMORY;
    end

// TODO: circular

    var _uv_buf_t buf = _uv_buf_init(&&stream.buffer[0], n!);
    _ceu_dbg_assert(_uv_is_writable(&&stream.handle));

    var int ret = _ceu_uv_write(&&req!, &&stream.handle, &&buf);
    _ceu_dbg_assert(ret >= 0);
    var _uv_write_t&& w;
    var int err;
    (w, err) = await UV_STREAM_WRITE until w==&&req!;
    _ceu_dbg_assert(err == 0);   // UV_STREAM_ERROR has already aborted me

    $stream.buffer = $stream.buffer - n!;

    escape 0;
end

native/pos do
#if 0
    ##define ceu_uv_close(a)           if (!uv_is_closing(a)) { uv_close(a,ceu_uv_free); }
#endif
    ##define ceu_uv_close(a)           uv_close(a,ceu_uv_free)
    ##define ceu_uv_listen(a,b)        uv_listen(a,b,ceu_uv_listen_cb)
    ##define ceu_uv_read_start(a)      uv_read_start(a,ceu_uv_read_alloc,ceu_uv_read_start_cb);
    ##define ceu_uv_write(a,b,c)       uv_write(a,b,c,1,ceu_uv_write_cb)

    void ceu_uv_free (uv_handle_t* h) {
        // TODO: other stream types
/*
        if (h->type == UV_TCP) {
            uv_stream_t* s = (uv_stream_t*)h;
            if (s->connect_req != NULL) {
printf(">>> FREE\n");
                free(s->connect_req);
                s->connect_req = NULL;
            }
        }
*/
        free(h);
    }

    void ceu_uv_listen_cb (uv_stream_t* s, int err) {
        ceu_dbg_assert(err >= 0);
        tceu_input_UV_STREAM_LISTEN p = { s, err };
        ceu_input(CEU_INPUT_UV_STREAM_LISTEN, &p);
    }

    ##define CEU_UV_STREAM_READ_ALLOC_DYN_INIT 1024

    void ceu_uv_read_alloc (uv_handle_t* h, size_t size, uv_buf_t* buf) {
        ceu_dbg_assert(h->data != NULL);
        tceu_vector* vec = (tceu_vector*) h->data;

        if (vec->is_dyn) {
            ceu_vector_setmax(vec, CEU_UV_STREAM_READ_ALLOC_DYN_INIT, 0);
        }

// TODO: circular
        *buf = uv_buf_init((char*)vec->buf+vec->len, vec->max-vec->len);
    }

    void ceu_uv_read_start_cb(uv_stream_t* s, ssize_t n, const uv_buf_t* _) {
        ceu_dbg_assert(n != 0); // TODO: if this happens, try to understand why

        ceu_dbg_assert(s->data != NULL);
        tceu_vector* vec = (tceu_vector*) s->data;
        if (n > 0) {
            if (ceu_vector_setlen_could(vec,vec->len+n,1) == 0) {
                n = UV_ENOBUFS;
            } else {
                ceu_vector_setlen(vec,vec->len+n,1);
            }
        }

        if (n < 0) {
            tceu_input_UV_STREAM_ERROR p = { s, n };
            ceu_input(CEU_INPUT_UV_STREAM_ERROR, &p);
        }

        {
            tceu_input_UV_STREAM_READ p = { s, n };
            ceu_input(CEU_INPUT_UV_STREAM_READ, &p);
        }
    }

    void ceu_uv_write_cb (uv_write_t* req, int err) {
        if (err < 0) {
            // if the "assert" fails, see if the error makes sense and extend it
            ceu_dbg_assert(err == UV__EOF);
            tceu_input_UV_STREAM_ERROR p = { req->handle, err };
            ceu_input(CEU_INPUT_UV_STREAM_ERROR, &p);
        }
        tceu_input_UV_STREAM_WRITE p = { req, err };
        ceu_input(CEU_INPUT_UV_STREAM_WRITE, &p);
        free(req);
    }
end

#endif
