#ifndef _UV_TCP_SERVER_CEU
#define _UV_TCP_SERVER_CEU

#include "uv/tcp.ceu"

#ifndef UV_TCP_SERVER_HANDLER_MAX
#define UV_TCP_SERVER_HANDLER_MAX
#endif

code/await UV_TCP_Server_Client (var& _uv_tcp_t server) -> void     // TODO: error
do
    var&? UV_TCP_Open client = spawn UV_TCP_Open();
    var int? err =
        watching client do
            var int ret = _uv_accept(&&server as _uv_stream_t&&, &&client!.tcp as _uv_stream_t&&);
            _ceu_dbg_assert(ret == 0);

/*
            var _sockaddr_in sock = _;
            var int len = sizeof(_sockaddr_in) as int;
            var int ret = _uv_tcp_getsockname(&&client!.tcp, (&&sock as _sockaddr&&), &&len);
            _ceu_dbg_assert(ret == 0);
            var int port = _ntohs(sock.sin_port);
*/

            await UV_TCP_Server_Handler(&client!.tcp);                   // TODO: error
        end;

    if err? then
        _fprintf(_stderr, "[client]: %s\n", _uv_strerror(err!));
    end
end

code/await UV_TCP_Server (var _char&& ip, var int port, var int backlog)
                            -> int  // err
do
    var&? UV_TCP_Open_Bind_Listen server = spawn UV_TCP_Open_Bind_Listen(ip,port,backlog);
    var int? err =
        watching server do
// TODO: receive as argument?
            pool[UV_TCP_SERVER_HANDLER_MAX] UV_TCP_Server_Client cs;
            every server!.ok do
                spawn UV_TCP_Server_Client(&server!.tcp) in cs;
            end
        end;
    escape err!;
end

#endif
