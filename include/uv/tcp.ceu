#ifndef _UV_TCP_CEU
#define _UV_TCP_CEU

#include "uv/stream.ceu"

native/plain
    _uv_tcp_t,
;

native/nohold
    _ceu_uv_tcp_connect,    // TODO: diconnect?
    _uv_ip4_name,
    _uv_tcp_bind,           // TODO: unbind?
    _uv_tcp_getsockname,
;

native
    _ceu_uv_tcp_init,
;

native/pos do
    ##define ceu_uv_tcp_init(a) uv_tcp_init(&ceu_uv_loop, a);
    ##define ceu_uv_tcp_connect(a,b,c) uv_tcp_connect(a,b,c,ceu_uv_connect_cb)

    void ceu_uv_connect_cb (uv_connect_t* c, int err) {
        tceu_input_UV_STREAM_CONNECT p = { c, err };
        ceu_input(CEU_INPUT_UV_STREAM_CONNECT, &p);
        free(c);
    }
end

#define UV_TCP_Listen(tcp, backlog) UV_Stream_Listen((tcp) as _uv_stream_t&&, backlog)
#define UV_TCP_Read(tcp, bytes) UV_Stream_Read((tcp) as _uv_stream_t&&, bytes)
#define UV_TCP_ReadLine(tcp, bytes) UV_Stream_ReadLine((tcp) as _uv_stream_t&&, bytes)
#define UV_TCP_Write(tcp, bytes) UV_Stream_Write((tcp) as _uv_stream_t&&, bytes)

code/await UV_TCP_Open (void) -> (var& _uv_tcp_t tcp) -> int // err
do
    var&? _uv_tcp_t tcp_ = &_malloc(sizeof(_uv_tcp_t))
        finalize (tcp_) with
            // free after "uv_close" below
        end;
    if not tcp_? then
        escape _UV_EAI_MEMORY;
    end
    tcp = &tcp_!;

    var int err1;
    do
        err1 = _ceu_uv_tcp_init(&&tcp_!);
    finalize (tcp_) with
        _ceu_uv_close(&&tcp_! as _uv_handle_t&&);
    end
    if err1 != 0 then
        escape err1;
    end

    var _uv_stream_t&& s;
    var int err2;
    (s,err2) = await UV_STREAM_ERROR until (s==(&&tcp_! as _uv_stream_t&&));
    escape err2;
end

code/await UV_TCP_Open_Bind_Listen (var _char&& ip, var int port, var int backlog)
                                    -> (var& _uv_tcp_t tcp, event& void ok)
                                        -> int // err
do
    var _sockaddr_in addr = _;
    _uv_ip4_addr(&&ip[0], port, &&addr);

    var&? UV_TCP_Open h = spawn UV_TCP_Open();
    var int? err1 =
        watching h do
            tcp = &h.tcp;
            _uv_tcp_bind(&&tcp, &&addr as _sockaddr&&, 0);
            var&? UV_Stream_Listen l = spawn UV_TCP_Listen(&tcp,backlog);
            var int? err2 =
                watching l do
                    ok = &l.ok;
                    await FOREVER;
                end;
            escape err2!;
        end;
    escape err1!;
end

code/await UV_TCP_Connect (var _char&& ip, var int port)
                            -> (var& _uv_tcp_t tcp, event void ok)
                                -> int  // err
do
    var _sockaddr_in dest = _;
    _uv_ip4_addr(ip, port, &&dest);

    var&? UV_TCP_Open h = spawn UV_TCP_Open();
    var int? err1 =
        watching h do
            tcp = &h.tcp;

            var&? _uv_connect_t connect = &_malloc(sizeof(_uv_connect_t))
                finalize (connect) with
                    // free on uv callback
                end

            _ceu_uv_tcp_connect(&&connect!, &&tcp, (&&dest as _sockaddr&&));

            var _uv_connect_t&& c;
            var int err2;
            (c,err2) = await UV_STREAM_CONNECT until c==&&connect!;
            if err2 != 0 then
                escape err2;
            end

            emit ok;
            await FOREVER;
        end;
    escape err1!;    // can only reach here with "err" set
end

#endif
