{
    "docs": [
        {
            "location": "/", 
            "text": "Introduction\n\n\nC\u00e9u-libuv supports the development of libuv applications in the programming\nlanguage \nC\u00e9u\n.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#introduction", 
            "text": "C\u00e9u-libuv supports the development of libuv applications in the programming\nlanguage  C\u00e9u .", 
            "title": "Introduction"
        }, 
        {
            "location": "/modes/", 
            "text": "Mode of Operation\n\n\nTODO", 
            "title": "Mode of Operation"
        }, 
        {
            "location": "/modes/#mode-of-operation", 
            "text": "TODO", 
            "title": "Mode of Operation"
        }, 
        {
            "location": "/fs/", 
            "text": "File System\n\n\nProvides file system operations.\n\n\nlibuv reference: \nhttp://docs.libuv.org/en/v1.x/fs.html\n\n\nInput Events\n\n\nUV_FS\n\n\ninput _uv_fs_t\n UV_FS;\n\n\n\n\n\n\nOccurrence:\n\n\nWhenever a filesystem operation completes.\n\n\n\n\n\n\nPayload:\n\n\n_uv_fs_t\n: pointer to the operation request\n\n\n\n\n\n\n\n\nlibuv reference: \nhttp://docs.libuv.org/en/v1.x/fs.html\n\n\nData Abstractions\n\n\nUV_FS_File\n\n\ndata UV_FS_File with\n    event void ok;\n    var   int  fd;\nend\n\n\n\n\nCode Abstractions\n\n\nUV_FS_Open\n\n\nOpens a file.\n\n\ncode/await UV_FS_Open (var _char\n path, var int flags, var int mode)\n                        -\n (var\n UV_FS_File file)\n                            -\n int\n\n\n\n\n\n\nParameters\n\n\npath\n:  path to the file\n\n\nflags\n: access mode flags\n\n\nmode\n:  file permission mode\n\n\n\n\n\n\nInitialization\n\n\nfile\n: created \nfile handle\n\n\n\n\n\n\nReturn\n\n\nint\n: open error\n\n\nreturns only case of error (always \n0\n)\n\n\n\n\n\n\n\n\n\n\n\n\nThe file is only ready for use after \nUV_FS_Open\n triggers \nfile.ok\n.\n\n\nC\u00e9u-libuv references:\n    \nceu_uv_fs_open\n,\n    \nUV_FS\n.\n\n\nlibuv references:\n    \nuv_fs_close\n,\n    \nuv_fs_req_cleanup\n.\n\n\nNote: all allocated libuv resources are automatically released on termination.\n\n\nExample\n\n\nOpens \nfile.txt\n and prints \nopen ok\n after the file is ready for use.\nIn case of failure, prints \nopen error\n along with the error code:\n\n\n#include \nuv/fs.ceu\n\n\nvar\n UV_FS_File file;\n\nvar int? err =\n    watching UV_FS_Open(\nfile.txt\n, _O_RDONLY, 0) -\n (\nfile) do\n        await file.ok;\n        // file is ready for use\n        _printf(\nopen ok\\n\n);\n    end;\nif err? then\n    _printf(\nopen error: %d\\n\n, err!);\nend\n\nescape 0;\n\n\n\n\n\n\n\nUV_FS_Read\n\n\nReads bytes from a file.\n\n\ncode/await UV_FS_Read (var\n UV_FS_File file, vector\n[] byte buf, var usize size, var usize offset)\n                        -\n ssize\n\n\n\n\n\n\nParameters\n\n\nfile\n:   \nfile handle\n to read from\n\n\nbuf\n:    destination buffer\n\n\nsize\n:   number of bytes to read\n\n\noffset\n: starting file offset\n\n\n\n\n\n\nReturn\n\n\nssize\n: actual number of bytes read\n\n\n=0\n: number of bytes\n\n\n0\n:  read error\n\n\n\n\n\n\n\n\n\n\n\n\nC\u00e9u-libuv references:\n    \nceu_uv_fs_read\n,\n    \nUV_FS\n.\n\n\nlibuv references:\n    \nuv_buf_init\n,\n    \nuv_fs_req_cleanup\n.\n\n\nNote: all allocated libuv resources are automatically released on termination.\n\n\nExample\n\n\nPrints the contents of \nfile.txt\n in a loop that reads the file in chunks of 10\nbytes:\n\n\n#include \nuv/fs.ceu\n\n\nvar\n UV_FS_File file;\n\nvar int? err =\n    watching UV_FS_Open(\nfile.txt\n, _O_RDONLY, 0) -\n (\nfile) do\n        await file.ok;\n\n        var usize offset = 0;\n        loop do\n            vector[11] byte buf;\n            var ssize n = await UV_FS_Read(\nfile,\nbuf,$$buf-1,offset);\n            if n == 0 then\n                break;\n            end\n            buf = buf .. [{'\\0'}];\n            _printf(\n%s\n, \nbuf[0]);\n            offset = offset + ($$buf-1);\n        end\n    end;\n_ceu_dbg_assert(not err?);\n\nescape 0;\n\n\n\n\n\n\n\nUV_FS_ReadLine\n\n\nReads a line from a file.\n\n\ncode/await UV_FS_ReadLine (var\n UV_FS_File file, vector\n[] byte buf, var usize offset)\n                            -\n ssize\n\n\n\n\n\n\nParameters\n\n\nfile\n:   \nfile handle\n to read from\n\n\nbuf\n:    destination buffer (excludes the leading \n\\n\n)\n\n\noffset\n: starting file offset\n\n\n\n\n\n\nReturn\n\n\nssize\n: actual number of bytes read\n\n\n=0\n: number of bytes (includes the leading \n\\n\n)\n\n\n0\n:  read error\n\n\n\n\n\n\n\n\n\n\n\n\nTODO: the file is currently read byte by byte.\n\n\nC\u00e9u-libuv references:\n    \nUV_FS_Read\n.\n\n\nExample\n\n\nPrints the contents of \nfile.txt\n in a loop that reads the file line by line:\n\n\n#include \nuv/fs.ceu\n\n\nvar\n UV_FS_File file;\n\nwatching UV_FS_Open(\nfile.txt\n, _O_RDONLY, 0) -\n (\nfile) do\n    await file.ok;\n\n    var usize off = 0;\n    loop do\n        vector[] byte line;\n        var ssize n = await UV_FS_ReadLine(\nfile,\nline,off);\n        if n \n= 0 then\n            break;\n        end\n        _printf(\nline = %s [%d]\\n\n, \nline[0], n as int);\n        off = off + (n as usize);\n    end\nend\n\nescape 0;\n\n\n\n\n\n\n\nUV_FS_Write\n\n\nWrite bytes from a file.\n\n\ncode/await UV_FS_Write (var\n UV_FS_File file, vector\n[] byte buf, var usize size, var usize offset)\n                        -\n ssize\n\n\n\n\n\n\nParameters\n\n\nfile\n:   \nfile handle\n to write to\n\n\nbuf\n:    source buffer\n\n\nsize\n:   number of bytes to write\n\n\noffset\n: starting file offset\n\n\n\n\n\n\nReturn\n\n\nssize\n: actual number of bytes written\n\n\n=0\n: number of bytes\n\n\n0\n:  write error\n\n\n\n\n\n\n\n\n\n\n\n\nC\u00e9u-libuv references:\n    \nceu_uv_fs_write\n,\n    \nUV_FS\n.\n\n\nlibuv references:\n    \nuv_buf_init\n,\n    \nuv_fs_req_cleanup\n.\n\n\nNote: all allocated libuv resources are automatically released on termination.\n\n\nExample\n\n\nWrites the string \nHello World\n to \nhello.txt\n:\n\n\n#include \nuv/fs.ceu\n\n\nvar\n UV_FS_File file;\n\nvar _mode_t mode = _S_IRUSR|_S_IWUSR|_S_IRGRP|_S_IWGRP|_S_IROTH;\n\nvar int? err =\n    watching UV_FS_Open(\nhello.txt\n, _O_CREAT|_O_WRONLY, mode) -\n (\nfile) do\n        await file.ok;\n        vector[] byte buf = [] .. \nHello World!\\n\n;\n        var ssize n = await UV_FS_Write(\nfile,\nbuf,$buf,0);\n        if (n\n0) or (n as usize)!=$buf then\n            _printf(\nwrite error\\n\n);\n        end\n    end;\nif err? then\n    _printf(\nopen error: %d\\n\n, err!);\nend\n\nescape 0;\n\n\n\n\n\n\n\nUV_FS_Fstat\n\n\nReads information about a file.\n\n\ncode/await UV_FS_Fstat (var\n UV_FS_File file, var\n _uv_stat_t stat)\n                        -\n int\n\n\n\n\n\n\nParameters\n\n\nfile\n: \nfile handle\n to write to\n\n\nstat\n: destination buffer\n\n\n\n\n\n\nReturn\n\n\nint\n: operation status\n\n\n0\n: success\n\n\n0\n: error\n\n\n\n\n\n\n\n\n\n\n\n\nC\u00e9u-libuv references:\n    \nceu_uv_fs_fstat\n,\n    \nUV_FS\n.\n\n\nlibuv references:\n    \nuv_fs_req_cleanup\n.\n\n\nNote: all allocated libuv resources are automatically released on termination.\n\n\nExample\n\n\nPrints the size of \nfile.txt\n in bytes:\n\n\n#include \nuv/fs.ceu\n\n\nvar\n UV_FS_File file;\n\nvar int? err =\n    watching UV_FS_Open(\nfile.txt\n, _O_RDONLY, 0) -\n (\nfile)\n    do\n        await file.ok;\n\n        var _uv_stat_t stat = _;\n        await UV_FS_Fstat(\nfile, \nstat);\n        _printf(\nsize = %ld\\n\n, stat.st_size);\n    end;\n\nif err? then\n    _printf(\nopen error: %d\\n\n, err!);\nend\n\nescape 0;", 
            "title": "File System"
        }, 
        {
            "location": "/fs/#file-system", 
            "text": "Provides file system operations.  libuv reference:  http://docs.libuv.org/en/v1.x/fs.html", 
            "title": "File System"
        }, 
        {
            "location": "/fs/#input-events", 
            "text": "", 
            "title": "Input Events"
        }, 
        {
            "location": "/fs/#uv_fs", 
            "text": "input _uv_fs_t  UV_FS;   Occurrence:  Whenever a filesystem operation completes.    Payload:  _uv_fs_t : pointer to the operation request     libuv reference:  http://docs.libuv.org/en/v1.x/fs.html", 
            "title": "UV_FS"
        }, 
        {
            "location": "/fs/#data-abstractions", 
            "text": "", 
            "title": "Data Abstractions"
        }, 
        {
            "location": "/fs/#uv_fs_file", 
            "text": "data UV_FS_File with\n    event void ok;\n    var   int  fd;\nend", 
            "title": "UV_FS_File"
        }, 
        {
            "location": "/fs/#code-abstractions", 
            "text": "", 
            "title": "Code Abstractions"
        }, 
        {
            "location": "/fs/#uv_fs_open", 
            "text": "Opens a file.  code/await UV_FS_Open (var _char  path, var int flags, var int mode)\n                        -  (var  UV_FS_File file)\n                            -  int   Parameters  path :  path to the file  flags : access mode flags  mode :  file permission mode    Initialization  file : created  file handle    Return  int : open error  returns only case of error (always  0 )       The file is only ready for use after  UV_FS_Open  triggers  file.ok .  C\u00e9u-libuv references:\n     ceu_uv_fs_open ,\n     UV_FS .  libuv references:\n     uv_fs_close ,\n     uv_fs_req_cleanup .  Note: all allocated libuv resources are automatically released on termination.", 
            "title": "UV_FS_Open"
        }, 
        {
            "location": "/fs/#example", 
            "text": "Opens  file.txt  and prints  open ok  after the file is ready for use.\nIn case of failure, prints  open error  along with the error code:  #include  uv/fs.ceu \n\nvar  UV_FS_File file;\n\nvar int? err =\n    watching UV_FS_Open( file.txt , _O_RDONLY, 0) -  ( file) do\n        await file.ok;\n        // file is ready for use\n        _printf( open ok\\n );\n    end;\nif err? then\n    _printf( open error: %d\\n , err!);\nend\n\nescape 0;", 
            "title": "Example"
        }, 
        {
            "location": "/fs/#uv_fs_read", 
            "text": "Reads bytes from a file.  code/await UV_FS_Read (var  UV_FS_File file, vector [] byte buf, var usize size, var usize offset)\n                        -  ssize   Parameters  file :    file handle  to read from  buf :    destination buffer  size :   number of bytes to read  offset : starting file offset    Return  ssize : actual number of bytes read  =0 : number of bytes  0 :  read error       C\u00e9u-libuv references:\n     ceu_uv_fs_read ,\n     UV_FS .  libuv references:\n     uv_buf_init ,\n     uv_fs_req_cleanup .  Note: all allocated libuv resources are automatically released on termination.", 
            "title": "UV_FS_Read"
        }, 
        {
            "location": "/fs/#example_1", 
            "text": "Prints the contents of  file.txt  in a loop that reads the file in chunks of 10\nbytes:  #include  uv/fs.ceu \n\nvar  UV_FS_File file;\n\nvar int? err =\n    watching UV_FS_Open( file.txt , _O_RDONLY, 0) -  ( file) do\n        await file.ok;\n\n        var usize offset = 0;\n        loop do\n            vector[11] byte buf;\n            var ssize n = await UV_FS_Read( file, buf,$$buf-1,offset);\n            if n == 0 then\n                break;\n            end\n            buf = buf .. [{'\\0'}];\n            _printf( %s ,  buf[0]);\n            offset = offset + ($$buf-1);\n        end\n    end;\n_ceu_dbg_assert(not err?);\n\nescape 0;", 
            "title": "Example"
        }, 
        {
            "location": "/fs/#uv_fs_readline", 
            "text": "Reads a line from a file.  code/await UV_FS_ReadLine (var  UV_FS_File file, vector [] byte buf, var usize offset)\n                            -  ssize   Parameters  file :    file handle  to read from  buf :    destination buffer (excludes the leading  \\n )  offset : starting file offset    Return  ssize : actual number of bytes read  =0 : number of bytes (includes the leading  \\n )  0 :  read error       TODO: the file is currently read byte by byte.  C\u00e9u-libuv references:\n     UV_FS_Read .", 
            "title": "UV_FS_ReadLine"
        }, 
        {
            "location": "/fs/#example_2", 
            "text": "Prints the contents of  file.txt  in a loop that reads the file line by line:  #include  uv/fs.ceu \n\nvar  UV_FS_File file;\n\nwatching UV_FS_Open( file.txt , _O_RDONLY, 0) -  ( file) do\n    await file.ok;\n\n    var usize off = 0;\n    loop do\n        vector[] byte line;\n        var ssize n = await UV_FS_ReadLine( file, line,off);\n        if n  = 0 then\n            break;\n        end\n        _printf( line = %s [%d]\\n ,  line[0], n as int);\n        off = off + (n as usize);\n    end\nend\n\nescape 0;", 
            "title": "Example"
        }, 
        {
            "location": "/fs/#uv_fs_write", 
            "text": "Write bytes from a file.  code/await UV_FS_Write (var  UV_FS_File file, vector [] byte buf, var usize size, var usize offset)\n                        -  ssize   Parameters  file :    file handle  to write to  buf :    source buffer  size :   number of bytes to write  offset : starting file offset    Return  ssize : actual number of bytes written  =0 : number of bytes  0 :  write error       C\u00e9u-libuv references:\n     ceu_uv_fs_write ,\n     UV_FS .  libuv references:\n     uv_buf_init ,\n     uv_fs_req_cleanup .  Note: all allocated libuv resources are automatically released on termination.", 
            "title": "UV_FS_Write"
        }, 
        {
            "location": "/fs/#example_3", 
            "text": "Writes the string  Hello World  to  hello.txt :  #include  uv/fs.ceu \n\nvar  UV_FS_File file;\n\nvar _mode_t mode = _S_IRUSR|_S_IWUSR|_S_IRGRP|_S_IWGRP|_S_IROTH;\n\nvar int? err =\n    watching UV_FS_Open( hello.txt , _O_CREAT|_O_WRONLY, mode) -  ( file) do\n        await file.ok;\n        vector[] byte buf = [] ..  Hello World!\\n ;\n        var ssize n = await UV_FS_Write( file, buf,$buf,0);\n        if (n 0) or (n as usize)!=$buf then\n            _printf( write error\\n );\n        end\n    end;\nif err? then\n    _printf( open error: %d\\n , err!);\nend\n\nescape 0;", 
            "title": "Example"
        }, 
        {
            "location": "/fs/#uv_fs_fstat", 
            "text": "Reads information about a file.  code/await UV_FS_Fstat (var  UV_FS_File file, var  _uv_stat_t stat)\n                        -  int   Parameters  file :  file handle  to write to  stat : destination buffer    Return  int : operation status  0 : success  0 : error       C\u00e9u-libuv references:\n     ceu_uv_fs_fstat ,\n     UV_FS .  libuv references:\n     uv_fs_req_cleanup .  Note: all allocated libuv resources are automatically released on termination.", 
            "title": "UV_FS_Fstat"
        }, 
        {
            "location": "/fs/#example_4", 
            "text": "Prints the size of  file.txt  in bytes:  #include  uv/fs.ceu \n\nvar  UV_FS_File file;\n\nvar int? err =\n    watching UV_FS_Open( file.txt , _O_RDONLY, 0) -  ( file)\n    do\n        await file.ok;\n\n        var _uv_stat_t stat = _;\n        await UV_FS_Fstat( file,  stat);\n        _printf( size = %ld\\n , stat.st_size);\n    end;\n\nif err? then\n    _printf( open error: %d\\n , err!);\nend\n\nescape 0;", 
            "title": "Example"
        }, 
        {
            "location": "/stream/", 
            "text": "Stream\n\n\nProvides stream operations.\n\n\nlibuv reference: \nhttp://docs.libuv.org/en/v1.x/stream.html\n\n\nInput Events\n\n\nUV_STREAM_LISTEN\n\n\ninput (_uv_stream_t\n, int) UV_STREAM_LISTEN;\n\n\n\n\n\n\nOccurrence:\n\n\nWhenever a stream server receives an incoming connection.\n\n\n\n\n\n\nPayload:\n\n\n_uv_stream_t\n: pointer to the stream server\n\n\n\n\n\n\n\n\nlibuv reference: \nhttp://docs.libuv.org/en/v1.x/stream.html#c.uv_connection_cb\n\n\nUV_STREAM_CONNECT\n\n\ninput (_uv_connect_t\n, int) UV_STREAM_CONNECT;\n\n\n\n\n\n\nOccurrence:\n\n\nWhenever a connection opens.\n\n\n\n\n\n\nPayload:\n\n\n_uv_connect_t\n: pointer to the connection\n\n\nint\n: open status\n\n\n0\n: success\n\n\n0\n: error\n\n\n\n\n\n\n\n\n\n\n\n\nlibuv reference: \nhttp://docs.libuv.org/en/v1.x/stream.html#c.uv_connect_cb\n\n\nUV_STREAM_READ\n\n\ninput (_uv_stream_t\n, ssize) UV_STREAM_READ;\n\n\n\n\n\n\nOccurrence:\n\n\nWhenever data is available on a stream.\n\n\n\n\n\n\nPayload:\n\n\n_uv_stream_t\n: pointer to the stream\n\n\nssize\n: number of bytes available\n\n\n0\n: data available\n\n\n0\n: error\n\n\n\n\n\n\n\n\n\n\n\n\nlibuv reference: \nhttp://docs.libuv.org/en/v1.x/stream.html#c.uv_read_cb\n\n\nUV_STREAM_WRITE\n\n\ninput (_uv_write_t\n, int) UV_STREAM_WRITE;\n\n\n\n\n\n\nOccurrence:\n\n\nWhenever writing to a stream completes.\n\n\n\n\n\n\nPayload:\n\n\n_uv_write_T\n: pointer to the write request\n\n\nint\n: completion status\n\n\n0\n: success\n\n\n0\n: error\n\n\n\n\n\n\n\n\n\n\n\n\nlibuv reference: \nhttp://docs.libuv.org/en/v1.x/stream.html#c.uv_write_cb\n\n\nUV_STREAM_ERROR\n\n\ninput (_uv_stream_t\n, int) UV_STREAM_ERROR;\n\n\n\n\n\n\nOccurrence:\n\n\nWhenever a read or write error occurs in a stream.\n\n\n\n\n\n\nPayload:\n\n\n_uv_stream_t\n: pointer to the stream\n\n\nint\n: error code\n\n\n\n\n\n\n\n\nUV_STREAM_ERROR\n always occurs before the corresponding \nUV_STREAM_READ\n or\n\nUV_STREAM_WRITE\n.\n\n\nlibuv reference: \nhttp://docs.libuv.org/en/v1.x/errors.html\n\n\n\n\n\nCode Abstractions\n\n\n\n\n\nUV_Stream_Listen\n\n\nStarts listening for incoming connections in a stream.\n\n\ncode/await UV_Stream_Listen (var\n _uv_stream_t stream, var int backlog)\n                                -\n (event\n void ok)\n                                    -\n int\n\n\n\n\n\n\nParameters\n\n\nstream\n:  stream to listen\n\n\nbacklog\n: number of connections the kernel might queue\n\n\n\n\n\n\nInitialization\n\n\nok\n: signalled on every new incoming connection\n\n\n\n\n\n\nReturn\n\n\nint\n: operation status\n\n\n0\n: success\n\n\n0\n: error\n\n\n\n\n\n\n\n\n\n\n\n\nC\u00e9u-libuv references:\n    \nceu_uv_listen\n,\n    \nUV_STREAM_LISTEN\n.\n\n\n\n\n\nUV_Stream_Read\n\n\nReads bytes from a stream continuously.\n\n\ncode/await UV_Stream_Read (var\n _uv_stream_t stream, vector\n[] byte buf)\n                            -\n (event\n usize ok)\n                                -\n int\n\n\n\n\n\n\nParameters\n\n\nstream\n: stream to read from\n\n\nbuf\n:    destination buffer\n\n\n\n\n\n\nInitialization\n\n\nok\n: signalled whenever new data is read to the destination buffer\n\n\n\n\n\n\nReturn\n\n\nint\n: read error\n\n\nreturns only in case of error (always \n0\n)\n\n\n\n\n\n\n\n\n\n\n\n\nC\u00e9u-libuv references:\n    \nceu_uv_read_start\n,\n    \nUV_STREAM_READ\n.\n\n\nlibuv references:\n    \nuv_read_stop\n.\n\n\nNote: all allocated libuv resources are automatically released on termination.\n\n\n\n\n\nUV_Stream_ReadLine\n\n\nReads a single line from a stream.\n\n\ncode/await UV_Stream_ReadLine (var\n _uv_stream_t stream, vector\n[] byte string)\n                                -\n void\n\n\n\n\n\n\nParameters\n\n\nstream\n: stream to read from\n\n\nstring\n: destination string buffer\n\n\n\n\n\n\nReturn\n\n\nvoid\n: nothing\n\n\n\n\n\n\n\n\nC\u00e9u-libuv references:\n    \nUV_Stream_Read\n.\n\n\n\n\n\nUV_Stream_Write\n\n\nWrite bytes to a stream.\n\n\ncode/await UV_Stream_Write (var\n _uv_stream_t stream, vector\n[] byte buf)\n                                -\n int\n\n\n\n\n\n\nParameters\n\n\nstream\n: stream to write to\n\n\nbuf\n:    source buffer\n\n\n\n\n\n\nReturn\n\n\nint\n: operation status\n\n\n0\n: success\n\n\n0\n: error\n\n\n\n\n\n\n\n\n\n\n\n\nC\u00e9u-libuv references:\n    \nceu_uv_write\n,\n    \nUV_STREAM_WRITE\n.\n\n\nNote: all allocated libuv resources are automatically released on termination.", 
            "title": "Stream"
        }, 
        {
            "location": "/stream/#stream", 
            "text": "Provides stream operations.  libuv reference:  http://docs.libuv.org/en/v1.x/stream.html", 
            "title": "Stream"
        }, 
        {
            "location": "/stream/#input-events", 
            "text": "", 
            "title": "Input Events"
        }, 
        {
            "location": "/stream/#uv_stream_listen", 
            "text": "input (_uv_stream_t , int) UV_STREAM_LISTEN;   Occurrence:  Whenever a stream server receives an incoming connection.    Payload:  _uv_stream_t : pointer to the stream server     libuv reference:  http://docs.libuv.org/en/v1.x/stream.html#c.uv_connection_cb", 
            "title": "UV_STREAM_LISTEN"
        }, 
        {
            "location": "/stream/#uv_stream_connect", 
            "text": "input (_uv_connect_t , int) UV_STREAM_CONNECT;   Occurrence:  Whenever a connection opens.    Payload:  _uv_connect_t : pointer to the connection  int : open status  0 : success  0 : error       libuv reference:  http://docs.libuv.org/en/v1.x/stream.html#c.uv_connect_cb", 
            "title": "UV_STREAM_CONNECT"
        }, 
        {
            "location": "/stream/#uv_stream_read", 
            "text": "input (_uv_stream_t , ssize) UV_STREAM_READ;   Occurrence:  Whenever data is available on a stream.    Payload:  _uv_stream_t : pointer to the stream  ssize : number of bytes available  0 : data available  0 : error       libuv reference:  http://docs.libuv.org/en/v1.x/stream.html#c.uv_read_cb", 
            "title": "UV_STREAM_READ"
        }, 
        {
            "location": "/stream/#uv_stream_write", 
            "text": "input (_uv_write_t , int) UV_STREAM_WRITE;   Occurrence:  Whenever writing to a stream completes.    Payload:  _uv_write_T : pointer to the write request  int : completion status  0 : success  0 : error       libuv reference:  http://docs.libuv.org/en/v1.x/stream.html#c.uv_write_cb", 
            "title": "UV_STREAM_WRITE"
        }, 
        {
            "location": "/stream/#uv_stream_error", 
            "text": "input (_uv_stream_t , int) UV_STREAM_ERROR;   Occurrence:  Whenever a read or write error occurs in a stream.    Payload:  _uv_stream_t : pointer to the stream  int : error code     UV_STREAM_ERROR  always occurs before the corresponding  UV_STREAM_READ  or UV_STREAM_WRITE .  libuv reference:  http://docs.libuv.org/en/v1.x/errors.html", 
            "title": "UV_STREAM_ERROR"
        }, 
        {
            "location": "/stream/#code-abstractions", 
            "text": "", 
            "title": "Code Abstractions"
        }, 
        {
            "location": "/stream/#uv_stream_listen_1", 
            "text": "Starts listening for incoming connections in a stream.  code/await UV_Stream_Listen (var  _uv_stream_t stream, var int backlog)\n                                -  (event  void ok)\n                                    -  int   Parameters  stream :  stream to listen  backlog : number of connections the kernel might queue    Initialization  ok : signalled on every new incoming connection    Return  int : operation status  0 : success  0 : error       C\u00e9u-libuv references:\n     ceu_uv_listen ,\n     UV_STREAM_LISTEN .", 
            "title": "UV_Stream_Listen"
        }, 
        {
            "location": "/stream/#uv_stream_read_1", 
            "text": "Reads bytes from a stream continuously.  code/await UV_Stream_Read (var  _uv_stream_t stream, vector [] byte buf)\n                            -  (event  usize ok)\n                                -  int   Parameters  stream : stream to read from  buf :    destination buffer    Initialization  ok : signalled whenever new data is read to the destination buffer    Return  int : read error  returns only in case of error (always  0 )       C\u00e9u-libuv references:\n     ceu_uv_read_start ,\n     UV_STREAM_READ .  libuv references:\n     uv_read_stop .  Note: all allocated libuv resources are automatically released on termination.", 
            "title": "UV_Stream_Read"
        }, 
        {
            "location": "/stream/#uv_stream_readline", 
            "text": "Reads a single line from a stream.  code/await UV_Stream_ReadLine (var  _uv_stream_t stream, vector [] byte string)\n                                -  void   Parameters  stream : stream to read from  string : destination string buffer    Return  void : nothing     C\u00e9u-libuv references:\n     UV_Stream_Read .", 
            "title": "UV_Stream_ReadLine"
        }, 
        {
            "location": "/stream/#uv_stream_write_1", 
            "text": "Write bytes to a stream.  code/await UV_Stream_Write (var  _uv_stream_t stream, vector [] byte buf)\n                                -  int   Parameters  stream : stream to write to  buf :    source buffer    Return  int : operation status  0 : success  0 : error       C\u00e9u-libuv references:\n     ceu_uv_write ,\n     UV_STREAM_WRITE .  Note: all allocated libuv resources are automatically released on termination.", 
            "title": "UV_Stream_Write"
        }, 
        {
            "location": "/tcp/", 
            "text": "TCP\n\n\nProvides TCP operations.\n\n\nlibuv reference: \nhttp://docs.libuv.org/en/v1.x/tcp.html\n\n\n\n\n\nCode Abstractions\n\n\n\n\n\nUV_TCP_Open\n\n\nOpens a raw TCP stream.\n\n\ncode/await UV_TCP_Open (void) -\n (var\n _uv_tcp_t tcp) -\n int\n\n\n\n\n\n\nParameters\n\n\nvoid\n: nothing\n\n\n\n\n\n\nInitialization\n\n\ntcp\n: opened \nTCP handle\n\n\n\n\n\n\nReturn\n\n\nint\n: TCP error\n\n\nreturns only in case of error (always \n0\n)\n\n\n\n\n\n\n\n\n\n\n\n\nC\u00e9u-libuv references:\n    \nceu_uv_tcp_init\n,\n    \nceu_uv_close\n,\n    \nUV_STREAM_ERROR\n.\n\n\nNote: all allocated libuv resources are automatically released on termination.\n\n\nExample\n\n\nvar\n _uv_tcp_t tcp;\nwatching UV_TCP_Open() -\n (\ntcp)\ndo\n    \n...\n   // use the raw `tcp` handle\nend\n\n\n\n\n\n\n\nOpens a connection TCP stream.\n\n\ncode/await UV_TCP_Connect (var _char\n ip, var int port)\n                            -\n (var\n _uv_tcp_t tcp, event\n void ok)\n                                -\n int\n\n\n\n\n\n\nParameters\n\n\nip\n:     remote host\n\n\nport\n:   remote port\n\n\n\n\n\n\nInitialization\n\n\ntcp\n:    disconnected \nTCP handle\n\n\nok\n:     signalled when \ntcp\n connects and is ready for use\n\n\n\n\n\n\nReturn\n\n\nint\n: TCP error\n\n\nreturns only in case of error (always \n0\n)\n\n\n\n\n\n\n\n\n\n\n\n\nExample\n\n\nvar\n   _uv_tcp_t tcp;\nevent\n void      ok_connected;\nwatching UV_TCP_Connect(\n127.0.0.1\n, 7000) -\n (\ntcp, \nok_connected) do\n    await ok_connected;\n    \n...\n   // use the connected `tcp` handle\nend\n\n\n\n\n\n\n\nUV_TCP_Listen\n\n\nStarts listening for incoming connections in a TCP stream.\n\n\nDefined in terms of \nUV_Stream_Listen\n:\n\n\n#define UV_TCP_Listen(tcp, backlog) UV_Stream_Listen((tcp) as _uv_stream_t\n, backlog)\n\n\n\n\nC\u00e9u-libuv references:\n    \nUV_Stream_Listen\n\n\nExample\n\n\nOpens\n a \nserver\n TCP handle, binds it to port \n7000\n, and then enters\nin listen mode.\nEach incoming connection triggers the event \nok_listen\n.\n\n\n#include \nuv/tcp.ceu\n\n\nvar\n _uv_tcp_t server;\nwatching UV_TCP_Open() -\n (\nserver) do\n    var _sockaddr_in addr = _;\n    _uv_ip4_addr(\n0.0.0.0\n, 7000, \naddr);\n    _uv_tcp_bind(\nserver, \naddr as _sockaddr\n, 0);\n\n    event\n void ok_listen;\n    watching UV_TCP_Listen(\nserver,128) -\n (\nok_listen) do\n        every ok_listen do\n            \n...\n   // handle incoming connection\n        end\n    end\nend\n\nescape 0;\n\n\n\n\n\n\n\nUV_TCP_Read\n\n\nReads bytes from a TCP stream continuously.\n\n\nDefined in terms of \nUV_Stream_Read\n:\n\n\n#define UV_TCP_Read(tcp, bytes) UV_Stream_Read((tcp) as _uv_stream_t\n, bytes)\n\n\n\n\nC\u00e9u-libuv references:\n    \nUV_Stream_Read\n\n\nExample\n\n\nConnects to \n127.0.0.1:7000\n and waits reading 10 bytes in a loop:\n\n\n#include \nuv/tcp.ceu\n\n\nvar\n _uv_tcp_t tcp;\nvar int? err =\n    watching UV_TCP_Open() -\n (\ntcp) do\n        var _uv_connect_t connect = _;\n        var _sockaddr_in dest = _;\n        _uv_ip4_addr(\n127.0.0.1\n, 7000, \ndest);\n        _ceu_uv_tcp_connect(\nconnect, \ntcp, (\ndest as _sockaddr\n));\n\n        var _uv_connect_t\n c;\n        var int status;\n        (c,status) = await UV_STREAM_CONNECT until c==\nconnect;\n        _ceu_dbg_assert(status == 0);\n\n        vector[11] byte buf;\n\n        event\n usize ok_read;\n        var int? err2 =\n            watching UV_TCP_Read(\ntcp,\nbuf) -\n (\nok_read) do\n                loop do\n                    await ok_read;\n                    if $buf == 10 then  // assumes server sends exactly 10 bytes\n                        break;\n                    end\n                end\n            end;\n        _ceu_dbg_assert(not err2?);\n\n        buf = buf .. [{'\\0'}];\n        _printf(\nbuf: %s\\n\n, \nbuf[0]);\n    end;\n_ceu_dbg_assert(not err?);\n\nescape 0;\n\n\n\n\n\n\n\nUV_TCP_ReadLine\n\n\nReads a single line from a TCP stream.\n\n\nDefined in terms of \nUV_Stream_ReadLine\n:\n\n\n#define UV_TCP_ReadLine(tcp, bytes) UV_Stream_ReadLine((tcp) as _uv_stream_t\n, bytes)\n\n\n\n\nC\u00e9u-libuv references:\n    \nUV_Stream_ReadLine\n\n\nExample\n\n\nTODO\n\n\n\n\n\nUV_TCP_Write\n\n\nWrite bytes to a TCP stream.\n\n\nDefined in terms of \nUV_Stream_Write\n:\n\n\n#define UV_TCP_Write(tcp, bytes) UV_Stream_Write((tcp) as _uv_stream_t\n, bytes)\n\n\n\n\nC\u00e9u-libuv references:\n    \nUV_Stream_Write\n\n\nExample\n\n\nTODO", 
            "title": "TCP"
        }, 
        {
            "location": "/tcp/#tcp", 
            "text": "Provides TCP operations.  libuv reference:  http://docs.libuv.org/en/v1.x/tcp.html", 
            "title": "TCP"
        }, 
        {
            "location": "/tcp/#code-abstractions", 
            "text": "", 
            "title": "Code Abstractions"
        }, 
        {
            "location": "/tcp/#uv_tcp_open", 
            "text": "Opens a raw TCP stream.  code/await UV_TCP_Open (void) -  (var  _uv_tcp_t tcp) -  int   Parameters  void : nothing    Initialization  tcp : opened  TCP handle    Return  int : TCP error  returns only in case of error (always  0 )       C\u00e9u-libuv references:\n     ceu_uv_tcp_init ,\n     ceu_uv_close ,\n     UV_STREAM_ERROR .  Note: all allocated libuv resources are automatically released on termination.", 
            "title": "UV_TCP_Open"
        }, 
        {
            "location": "/tcp/#example", 
            "text": "var  _uv_tcp_t tcp;\nwatching UV_TCP_Open() -  ( tcp)\ndo\n     ...    // use the raw `tcp` handle\nend   Opens a connection TCP stream.  code/await UV_TCP_Connect (var _char  ip, var int port)\n                            -  (var  _uv_tcp_t tcp, event  void ok)\n                                -  int   Parameters  ip :     remote host  port :   remote port    Initialization  tcp :    disconnected  TCP handle  ok :     signalled when  tcp  connects and is ready for use    Return  int : TCP error  returns only in case of error (always  0 )", 
            "title": "Example"
        }, 
        {
            "location": "/tcp/#example_1", 
            "text": "var    _uv_tcp_t tcp;\nevent  void      ok_connected;\nwatching UV_TCP_Connect( 127.0.0.1 , 7000) -  ( tcp,  ok_connected) do\n    await ok_connected;\n     ...    // use the connected `tcp` handle\nend", 
            "title": "Example"
        }, 
        {
            "location": "/tcp/#uv_tcp_listen", 
            "text": "Starts listening for incoming connections in a TCP stream.  Defined in terms of  UV_Stream_Listen :  #define UV_TCP_Listen(tcp, backlog) UV_Stream_Listen((tcp) as _uv_stream_t , backlog)  C\u00e9u-libuv references:\n     UV_Stream_Listen", 
            "title": "UV_TCP_Listen"
        }, 
        {
            "location": "/tcp/#example_2", 
            "text": "Opens  a  server  TCP handle, binds it to port  7000 , and then enters\nin listen mode.\nEach incoming connection triggers the event  ok_listen .  #include  uv/tcp.ceu \n\nvar  _uv_tcp_t server;\nwatching UV_TCP_Open() -  ( server) do\n    var _sockaddr_in addr = _;\n    _uv_ip4_addr( 0.0.0.0 , 7000,  addr);\n    _uv_tcp_bind( server,  addr as _sockaddr , 0);\n\n    event  void ok_listen;\n    watching UV_TCP_Listen( server,128) -  ( ok_listen) do\n        every ok_listen do\n             ...    // handle incoming connection\n        end\n    end\nend\n\nescape 0;", 
            "title": "Example"
        }, 
        {
            "location": "/tcp/#uv_tcp_read", 
            "text": "Reads bytes from a TCP stream continuously.  Defined in terms of  UV_Stream_Read :  #define UV_TCP_Read(tcp, bytes) UV_Stream_Read((tcp) as _uv_stream_t , bytes)  C\u00e9u-libuv references:\n     UV_Stream_Read", 
            "title": "UV_TCP_Read"
        }, 
        {
            "location": "/tcp/#example_3", 
            "text": "Connects to  127.0.0.1:7000  and waits reading 10 bytes in a loop:  #include  uv/tcp.ceu \n\nvar  _uv_tcp_t tcp;\nvar int? err =\n    watching UV_TCP_Open() -  ( tcp) do\n        var _uv_connect_t connect = _;\n        var _sockaddr_in dest = _;\n        _uv_ip4_addr( 127.0.0.1 , 7000,  dest);\n        _ceu_uv_tcp_connect( connect,  tcp, ( dest as _sockaddr ));\n\n        var _uv_connect_t  c;\n        var int status;\n        (c,status) = await UV_STREAM_CONNECT until c== connect;\n        _ceu_dbg_assert(status == 0);\n\n        vector[11] byte buf;\n\n        event  usize ok_read;\n        var int? err2 =\n            watching UV_TCP_Read( tcp, buf) -  ( ok_read) do\n                loop do\n                    await ok_read;\n                    if $buf == 10 then  // assumes server sends exactly 10 bytes\n                        break;\n                    end\n                end\n            end;\n        _ceu_dbg_assert(not err2?);\n\n        buf = buf .. [{'\\0'}];\n        _printf( buf: %s\\n ,  buf[0]);\n    end;\n_ceu_dbg_assert(not err?);\n\nescape 0;", 
            "title": "Example"
        }, 
        {
            "location": "/tcp/#uv_tcp_readline", 
            "text": "Reads a single line from a TCP stream.  Defined in terms of  UV_Stream_ReadLine :  #define UV_TCP_ReadLine(tcp, bytes) UV_Stream_ReadLine((tcp) as _uv_stream_t , bytes)  C\u00e9u-libuv references:\n     UV_Stream_ReadLine", 
            "title": "UV_TCP_ReadLine"
        }, 
        {
            "location": "/tcp/#example_4", 
            "text": "TODO", 
            "title": "Example"
        }, 
        {
            "location": "/tcp/#uv_tcp_write", 
            "text": "Write bytes to a TCP stream.  Defined in terms of  UV_Stream_Write :  #define UV_TCP_Write(tcp, bytes) UV_Stream_Write((tcp) as _uv_stream_t , bytes)  C\u00e9u-libuv references:\n     UV_Stream_Write", 
            "title": "UV_TCP_Write"
        }, 
        {
            "location": "/tcp/#example_5", 
            "text": "TODO", 
            "title": "Example"
        }, 
        {
            "location": "/license/", 
            "text": "License\n\n\nC\u00e9u-Arduino is distributed under the MIT license reproduced below:\n\n\n Copyright (C) 2012-2017 Francisco Sant'Anna\n\n Permission is hereby granted, free of charge, to any person obtaining a copy of\n this software and associated documentation files (the \nSoftware\n), to deal in\n the Software without restriction, including without limitation the rights to\n use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n of the Software, and to permit persons to whom the Software is furnished to do\n so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in all\n copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \nAS IS\n, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n SOFTWARE.", 
            "title": "License"
        }, 
        {
            "location": "/license/#license", 
            "text": "C\u00e9u-Arduino is distributed under the MIT license reproduced below:   Copyright (C) 2012-2017 Francisco Sant'Anna\n\n Permission is hereby granted, free of charge, to any person obtaining a copy of\n this software and associated documentation files (the  Software ), to deal in\n the Software without restriction, including without limitation the rights to\n use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n of the Software, and to permit persons to whom the Software is furnished to do\n so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in all\n copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED  AS IS , WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n SOFTWARE.", 
            "title": "License"
        }
    ]
}